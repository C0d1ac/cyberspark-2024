
'''
The main idea of this task is to look what are additive groups. Usually Shared secret are calculated with the power here we just multiply so the shared secret is (a*b*g) % p
So in order to get a we need to calculate the inverse of g which is (g**-1) % p and then multiply it with B to get shared secret. 

'''
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import long_to_bytes , inverse
from hashlib import sha256
p=70695460368073651094554812437650001271943161991221082480650040299450364547790831379707156191345169143252383072880239679606261123668314312803134282151522089768303020983
g=57557364340825502551379598471469585256416521358857415287688036634321180280293573084970342613711954553015242075169413607953741856285236906392242103855468866658392534283
A=17055008941604107316227742356225743670231107885747302603642827322901049995671997631136785822191696617343831882233586557618572533137613525440122519980430602756473894221
B=32296247647102333645739720842482135159733512882008589248431384472634665580686139430712742926303304549296333005837716110865058107207874073151066514354416266800914503135
encrypted ="abaf79e5f510531e844a7f4884a604bea7584d076295ee7640d50e7d6334589b0b21532f8f42625889cbaaa2dc10be2d"
a_priv = A*inverse(g,p)
shared_key = B*a_priv % p

def decrypt(shared_key, ct):
    key = sha256(long_to_bytes(shared_key)).digest()[:16]
    cipher = AES.new(key, AES.MODE_ECB)
    pt = unpad(cipher.decrypt(bytes.fromhex(ct)), 16)
    return pt


print(decrypt(shared_key, encrypted))


#flag : Spark{b0a7a2e4653871eac135dc12024e8a04dbd76fbf}
