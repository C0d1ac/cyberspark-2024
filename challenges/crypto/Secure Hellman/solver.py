
'''
The trick in this task is to notice that instead of calculating A = pow(g,a,p) as usual we are doing ^ and ^ in python is the XOR so it's pretty basic to reverse the operation and get the flag.  
'''

from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import long_to_bytes, inverse
from hashlib import sha256
from sympy.ntheory import discrete_log

p=105449717383769257506071580115417075226499483994198263764628368209513190921854418026618127117772867037774884148275079978498861190470969980295918974725863700091448436567
g=84437673131130610221886901378599980648695409563590187599602030894407324865981528836383484606491621421120870789141907020509304115791794185190841435382085114386196816449 
A=108453181571149884768132955966761337824969125782678567218595135453954801993248035665438092245092203484353277874112896905042399465603397642602903483460710298640146641897
B=19325352603718582618986472380250755408787642631736359235285229352650286477233535988865095593934347582393269710575730154118652743159464578981954239588109474103946822946
encrypted = "784ebbcf8ffddf2dd8fbd9064136178b14a04fa5c0e6d7ca6825a7e98461d74989d382da5217c45b6c1770e5c97a689d"

a = (g ^ A) % p
shared_key = B ^ a % p
def decrypt(shared_key, ct):
    key = sha256(long_to_bytes(shared_key)).digest()[:16]
    cipher = AES.new(key, AES.MODE_ECB)
    pt = unpad(cipher.decrypt(bytes.fromhex(ct)), 16)
    return pt


print(decrypt(shared_key, encrypted))


#flag : Spark{ee99cadc1ef436aafaab8ad66b2d2cadd8674981}
#Author : Quiiper